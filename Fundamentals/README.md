# Fundamentals

Strong fundamentals form the foundation of excellent software development. Understanding core concepts makes learning new technologies easier.

## üìö Topics Covered

### Computer Science Basics

#### [Computer-Science](./Computer-Science/)
- Data structures
  - Arrays
  - Linked Lists
  - Stacks
  - Queues
  - Trees
  - Graphs
  - Hash Tables
- Algorithms
  - Sorting algorithms
  - Searching algorithms
  - Recursion
  - Dynamic programming
  - Greedy algorithms
- Complexity analysis (Big O notation)
- Object-oriented programming (OOP)
- Functional programming concepts
- Memory management
- Operating systems basics

#### [Algorithms-Data-Structures](./Algorithms-Data-Structures/)
- Algorithm complexity
- Time complexity (O(1), O(log n), O(n), O(n¬≤))
- Space complexity
- Common algorithms:
  - Binary search
  - Quick sort
  - Merge sort
  - Breadth-first search (BFS)
  - Depth-first search (DFS)
- Data structure implementations
- Problem-solving patterns
- LeetCode-style problems

### Networking

#### [Networking](./Networking/)
- OSI model
- TCP/IP model
- HTTP vs HTTPS
- DNS (Domain Name System)
- IP addresses and subnets
- Ports and protocols
- Load balancing
- CDN (Content Delivery Network)
- WebSockets
- TCP vs UDP

#### [HTTP-HTTPS](./HTTP-HTTPS/)
- HTTP methods (GET, POST, PUT, DELETE, PATCH)
- HTTP status codes
- HTTP headers
- Request/Response cycle
- HTTPS and TLS/SSL
- Cookies and sessions
- Caching headers
- HTTP/2 and HTTP/3
- REST principles
- API design with HTTP

### Software Engineering

#### [Software-Engineering](./Software-Engineering/)
- Software development lifecycle (SDLC)
- Agile methodologies
- Software architecture patterns
- Design patterns
- Code review practices
- Documentation
- Technical debt
- Refactoring
- Code quality metrics
- Software estimation
- Requirements gathering
- System analysis

## üéØ Learning Path

### Core Concepts
1. Data structures and algorithms
2. Object-oriented programming
3. Functional programming basics
4. Networking fundamentals
5. HTTP/HTTPS deep dive

### Applied Concepts
1. Problem-solving patterns
2. System design basics
3. Software engineering practices
4. Complexity analysis
5. Best practices

## üìä Big O Notation

### Common Complexities
- **O(1)** - Constant time (array access)
- **O(log n)** - Logarithmic (binary search)
- **O(n)** - Linear (array iteration)
- **O(n log n)** - Linearithmic (efficient sorting)
- **O(n¬≤)** - Quadratic (nested loops)
- **O(2‚Åø)** - Exponential (recursive Fibonacci)

### Optimization Goals
- Reduce time complexity
- Reduce space complexity
- Balance between time and space

## üîÑ Data Structures

### When to Use What

**Arrays**
- Fast access by index
- Fixed size or dynamic
- Use for: Lists, matrices

**Linked Lists**
- Dynamic size
- Efficient insertion/deletion
- Use for: Stacks, queues

**Hash Tables**
- Fast lookups (O(1) average)
- Key-value pairs
- Use for: Caching, indexing

**Trees**
- Hierarchical data
- Efficient searching
- Use for: File systems, databases

**Graphs**
- Network relationships
- Complex connections
- Use for: Social networks, routing

## üåê HTTP Fundamentals

### HTTP Methods
- **GET** - Retrieve data
- **POST** - Create resource
- **PUT** - Update resource
- **DELETE** - Remove resource
- **PATCH** - Partial update

### Status Code Ranges
- **2xx** - Success
- **3xx** - Redirection
- **4xx** - Client error
- **5xx** - Server error

### Important Headers
- `Content-Type` - Response format
- `Authorization` - Authentication
- `Cache-Control` - Caching directives
- `CORS` headers - Cross-origin requests

## üíª Programming Paradigms

### Object-Oriented Programming (OOP)
- Encapsulation
- Inheritance
- Polymorphism
- Abstraction

### Functional Programming
- Pure functions
- Immutability
- Higher-order functions
- Function composition

## üèóÔ∏è Software Engineering Principles

### SOLID Principles
- Single Responsibility
- Open/Closed
- Liskov Substitution
- Interface Segregation
- Dependency Inversion

### DRY, KISS, YAGNI
- **DRY** - Don't Repeat Yourself
- **KISS** - Keep It Simple, Stupid
- **YAGNI** - You Aren't Gonna Need It

## üìù Best Practices

### Code Quality
- Write readable code
- Use meaningful names
- Keep functions small
- Single responsibility
- Document complex logic

### Problem Solving
- Understand the problem
- Break into smaller problems
- Consider edge cases
- Test your solution
- Optimize if needed

## üéì Learning Resources

### Data Structures & Algorithms
- LeetCode
- HackerRank
- CodeWars
- Books: "Cracking the Coding Interview"

### Computer Science
- CS50 (Harvard)
- Computer Science courses
- Algorithm visualization tools

### Networking
- HTTP documentation (MDN)
- Network protocols documentation
- Networking courses

## üîó Related Topics

- [Architecture](../Architecture/) - Applied fundamentals
- [Frontend](../Frontend/) - Client-side implementation
- [Backend](../Backend/) - Server-side implementation
- [Tools](../Tools/) - Development tools

---

Strong fundamentals enable faster learning and better problem-solving. Invest time in understanding these core concepts deeply.

